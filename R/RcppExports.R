# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Perform Accelerated Spatial Meta Kriging (ASMK)
#'
#' @param data [list] three elements: first named \eqn{Y}, second named \eqn{X}, third named \eqn{crd}
#' @param priors [list] priors: named \eqn{\mu_b},\eqn{V_b},\eqn{a},\eqn{b}
#' @param hyperpar [list] two elemets: first named \eqn{\delta}, second named \eqn{\phi}
#' @param K [integer] number of subsets
#' @param newdata [list] two elements: second named \eqn{X}, third named \eqn{crd}
#' @param R [integer] number of poterior predictive sample
#'
#' @return [list] posterior update parameters
#' @export
spASMK <- function(data, priors, hyperpar, K, newdata, R = 250L) {
    .Call(`_ASMK_spASMK`, data, priors, hyperpar, K, newdata, R)
}

#' Compute the BPS spatial prediction given a set of stacking weights
#'
#' @param data [list] two elements: first named \eqn{Y}, second named \eqn{X}
#' @param X_u [matrix] unobserved instances covariate matrix
#' @param priors [list] priors: named \eqn{\mu_b},\eqn{V_b},\eqn{a},\eqn{b}
#' @param coords [matrix] sample coordinates for X and Y
#' @param crd_u [matrix] unboserved instances coordinates
#' @param hyperpar [list] two elemets: first named \eqn{\delta}, second named \eqn{\phi}
#' @param W [matrix] set of stacking weights
#' @param R [integer] number of desired samples
#'
#' @return [list] BPS posterior predictive samples
NULL

#' Compute the Euclidean distance matrix
#'
#' @param X [matrix] (tipically of \eqn{N} coordindates on \eqn{\mathbb{R}^2} )
#'
#' @return [matrix] distance matrix of the elements of \eqn{X}
#' @export
arma_dist <- function(X) {
    .Call(`_ASMK_arma_dist`, X)
}

#' Build a grid from two vector (i.e. equivalent to \code{expand.grid()} in \code{R})
#'
#' @param x [vector] first vector of numeric elements
#' @param y [vector] second vector of numeric elements
#'
#' @return [matrix] expanded grid of combinations
#' @export
expand_grid_cpp <- function(x, y) {
    .Call(`_ASMK_expand_grid_cpp`, x, y)
}

#' Function to sample integers (index)
#'
#' @param size [integer] dimension of the set to sample
#' @param length [integer] number of elements to sample
#' @param p [vector] sampling probabilities
#'
#' @return [vector] sample of integers
#' @export
sample_index <- function(size, length, p) {
    .Call(`_ASMK_sample_index`, size, length, p)
}

#' Function to subset data for meta-analysis
#'
#' @param data [list] three elements: first named \eqn{Y}, second named \eqn{X}, third named \eqn{crd}
#' @param K [integer] number of desired subsets
#'
#' @return [list] subsets of data, and the set of indexes
#' @export
subset_data <- function(data, K) {
    .Call(`_ASMK_subset_data`, data, K)
}

#' Compute the parameters for the posteriors distribution of \eqn{\beta} and \eqn{\Sigma} (i.e. updated parameters)
#'
#' @param data [list] two elements: first named \eqn{Y}, second named \eqn{X}
#' @param priors [list] priors: named \eqn{\mu_b},\eqn{V_b},\eqn{a},\eqn{b}
#' @param coords [matrix] sample coordinates for X and Y
#' @param hyperpar [list] two elemets: first named \eqn{\delta}, second named \eqn{\phi}
#'
#' @return [list] posterior update parameters
#'
fit_cpp <- function(data, priors, coords, hyperpar) {
    .Call(`_ASMK_fit_cpp`, data, priors, coords, hyperpar)
}

#' Sample R draws from the posterior distributions
#'
#' @param poster [list] output from \code{fit_cpp} function
#' @param R [integer] number of posterior samples
#' @param par [boolean] if \code{TRUE} only \eqn{\beta} and \eqn{\sigma^2} are sampled (\eqn{\omega} is omitted)
#' @param p [integer] if \code{par = TRUE}, it specifies the column number of \eqn{X}
#'
#' @return [list] posterior samples
#'
post_draws <- function(poster, R, par, p) {
    .Call(`_ASMK_post_draws`, poster, R, par, p)
}

#' Draw from the conditional posterior predictive for a set of unobserved covariates
#'
#' @param data [list] two elements: first named \eqn{Y}, second named \eqn{X}
#' @param X_u [matrix] unobserved instances covariate matrix
#' @param iRphi_s [matrix] inverse of the sample correlation matrix
#' @param d_u [matrix] unobserved instances distance matrix
#' @param d_us [matrix] cross-distance between unobserved and observed instances matrix
#' @param hyperpar [list] two elemets: first named \eqn{\delta}, second named \eqn{\phi}
#' @param poster [list] output from \code{fit_cpp} function
#'
#' @return [list] posterior predictive samples
#'
r_pred_cpp <- function(data, X_u, iRphi_s, d_u, d_us, hyperpar, poster) {
    .Call(`_ASMK_r_pred_cpp`, data, X_u, iRphi_s, d_u, d_us, hyperpar, poster)
}

#' Evaluate the density of a set of unobserved response with respect to the conditional posterior predictive
#'
#' @param data [list] two elements: first named \eqn{Y}, second named \eqn{X}
#' @param X_u [matrix] unobserved instances covariate matrix
#' @param Y_u [matrix] unobserved instances response matrix
#' @param iRphi_s [matrix] inverse of the sample correlation matrix
#' @param d_u [matrix] unobserved instances distance matrix
#' @param d_us [matrix] cross-distance between unobserved and observed instances matrix
#' @param hyperpar [list] two elemets: first named \eqn{\delta}, second named \eqn{\phi}
#' @param poster [list] output from \code{fit_cpp} function
#'
#' @return [vector] posterior predictive density evaluations
#'
d_pred_cpp <- function(data, X_u, Y_u, iRphi_s, d_u, d_us, hyperpar, poster) {
    .Call(`_ASMK_d_pred_cpp`, data, X_u, Y_u, iRphi_s, d_u, d_us, hyperpar, poster)
}

#' Compute the LOOCV of the density evaluations for fixed values of the hyperparameters
#'
#' @param data [list] two elements: first named \eqn{Y}, second named \eqn{X}
#' @param priors [list] priors: named \eqn{\mu_b},\eqn{V_b},\eqn{a},\eqn{b}
#' @param coords [matrix] sample coordinates for X and Y
#' @param hyperpar [list] two elemets: first named \eqn{\delta}, second named \eqn{\phi}
#'
#' @return [vector] posterior predictive density evaluations
#'
dens_loocv <- function(data, priors, coords, hyperpar) {
    .Call(`_ASMK_dens_loocv`, data, priors, coords, hyperpar)
}

#' Compute the KCV of the density evaluations for fixed values of the hyperparameters
#'
#' @param data [list] two elements: first named \eqn{Y}, second named \eqn{X}
#' @param priors [list] priors: named \eqn{\mu_b},\eqn{V_b},\eqn{a},\eqn{b}
#' @param coords [matrix] sample coordinates for X and Y
#' @param hyperpar [list] two elemets: first named \eqn{\delta}, second named \eqn{\phi}
#' @param K [integer] number of folds
#'
#' @return [vector] posterior predictive density evaluations
#'
dens_kcv <- function(data, priors, coords, hyperpar, K) {
    .Call(`_ASMK_dens_kcv`, data, priors, coords, hyperpar, K)
}

#' Return the CV predictive density evaluations for all the model combinations
#'
#' @param data [list] two elements: first named \eqn{Y}, second named \eqn{X}
#' @param priors [list] priors: named \eqn{\mu_b},\eqn{V_b},\eqn{a},\eqn{b}
#' @param coords [matrix] sample coordinates for X and Y
#' @param hyperpar [list] two elemets: first named \eqn{\delta}, second named \eqn{\phi}
#' @param useKCV [boolean] if \code{TRUE} K-fold cross validation is used instead of LOOCV (no \code{default})
#' @param K [integer] number of folds
#'
#' @return [matrix] posterior predictive density evaluations (each columns represent a different model)
#'
models_dens <- function(data, priors, coords, hyperpar, useKCV, K) {
    .Call(`_ASMK_models_dens`, data, priors, coords, hyperpar, useKCV, K)
}

#' Compute the KCV of the density evaluations for fixed values of the hyperparameters
#'
#' @param data [list] two elements: first named \eqn{Y}, second named \eqn{X}
#' @param priors [list] priors: named \eqn{\mu_b},\eqn{V_b},\eqn{a},\eqn{b}
#' @param coords [matrix] sample coordinates for X and Y
#' @param hyperpar [list] two elemets: first named \eqn{\delta}, second named \eqn{\phi}
#' @param K [integer] number of folds
#'
#' @return [list] posterior predictive density evaluations
#'
dens_kcv2 <- function(data, priors, coords, hyperpar, K) {
    .Call(`_ASMK_dens_kcv2`, data, priors, coords, hyperpar, K)
}

#' Return the CV predictive density evaluations for all the model combinations
#'
#' @param data [list] two elements: first named \eqn{Y}, second named \eqn{X}
#' @param priors [list] priors: named \eqn{\mu_b},\eqn{V_b},\eqn{a},\eqn{b}
#' @param coords [matrix] sample coordinates for X and Y
#' @param hyperpar [list] two elemets: first named \eqn{\delta}, second named \eqn{\phi}
#' @param K [integer] number of folds
#'
#' @return [matrix] posterior predictive density evaluations (each columns represent a different model)
#'
models_dens2 <- function(data, priors, coords, hyperpar, K) {
    .Call(`_ASMK_models_dens2`, data, priors, coords, hyperpar, K)
}

#' Compute the BPS weights by convex optimization
#'
#' @param scores [matrix] \eqn{N \times K} of expected predictive density evaluations for the K models considered
#'
#' @return conv_opt [function] to perform convex optimiazion with CVXR R package
#'
CVXR_opt <- function(scores) {
    .Call(`_ASMK_CVXR_opt`, scores)
}

#' Compute the BPS weights by convex optimization
#'
#' @param data [list] two elements: first named \eqn{Y}, second named \eqn{X}
#' @param priors [list] priors: named \eqn{\mu_b},\eqn{V_b},\eqn{a},\eqn{b}
#' @param coords [matrix] sample coordinates for X and Y
#' @param hyperpar [list] two elemets: first named \eqn{\delta}, second named \eqn{\phi}
#' @param K [integer] number of folds
#'
#' @return [matrix] posterior predictive density evaluations (each columns represent a different model)
#'
BPSweights_cpp <- function(data, priors, coords, hyperpar, K) {
    .Call(`_ASMK_BPSweights_cpp`, data, priors, coords, hyperpar, K)
}

#' Compute the BPS weights by convex optimization
#'
#' @param data [list] two elements: first named \eqn{Y}, second named \eqn{X}
#' @param priors [list] priors: named \eqn{\mu_b},\eqn{V_b},\eqn{a},\eqn{b}
#' @param coords [matrix] sample coordinates for X and Y
#' @param hyperpar [list] two elemets: first named \eqn{\delta}, second named \eqn{\phi}
#' @param K [integer] number of folds
#'
#' @return [matrix] posterior predictive density evaluations (each columns represent a different model)
#'
BPSweights_cpp2 <- function(data, priors, coords, hyperpar, K) {
    .Call(`_ASMK_BPSweights_cpp2`, data, priors, coords, hyperpar, K)
}

#' Combine subset models wiht BPS
#'
#' @param fit_list [list] K fitted model outputs composed by two elements each: first named \eqn{epd}, second named \eqn{W}
#' @param K [integer] number of folds
#'
#' @return [matrix] posterior predictive density evaluations (each columns represent a different model)
#'
BPS_combine <- function(fit_list, K, rp) {
    .Call(`_ASMK_BPS_combine`, fit_list, K, rp)
}

#' Compute the BPS spatial prediction given a set of stacking weights
#'
#' @param data [list] two elements: first named \eqn{Y}, second named \eqn{X}
#' @param X_u [matrix] unobserved instances covariate matrix
#' @param priors [list] priors: named \eqn{\mu_b},\eqn{V_b},\eqn{a},\eqn{b}
#' @param coords [matrix] sample coordinates for X and Y
#' @param crd_u [matrix] unboserved instances coordinates
#' @param hyperpar [list] two elemets: first named \eqn{\delta}, second named \eqn{\phi}
#' @param W [matrix] set of stacking weights
#' @param R [integer] number of desired samples
#'
#' @return [list] BPS posterior predictive samples
#'
BPS_SpatialPrediction_cpp <- function(data, X_u, priors, coords, crd_u, hyperpar, W, R) {
    .Call(`_ASMK_BPS_SpatialPrediction_cpp`, data, X_u, priors, coords, crd_u, hyperpar, W, R)
}

fast_BPSpred <- function(data, X_u, priors, coords, crd_u, hyperpar, W, R) {
    .Call(`_ASMK_fast_BPSpred`, data, X_u, priors, coords, crd_u, hyperpar, W, R)
}

#' Compute the BPS spatial prediction given a set of stacking weights
#'
#' @param data [list] two elements: first named \eqn{Y}, second named \eqn{X}
#' @param X_u [matrix] unobserved instances covariate matrix
#' @param priors [list] priors: named \eqn{\mu_b},\eqn{V_b},\eqn{a},\eqn{b}
#' @param coords [matrix] sample coordinates for X and Y
#' @param crd_u [matrix] unboserved instances coordinates
#' @param hyperpar [list] two elemets: first named \eqn{\delta}, second named \eqn{\phi}
#' @param W [matrix] set of stacking weights
#' @param R [integer] number of desired samples
#'
#' @return [list] BPS posterior predictive samples
#'
BPS_SpatialPrediction_cpp2 <- function(data, X_u, priors, coords, crd_u, hyperpar, W, R) {
    .Call(`_ASMK_BPS_SpatialPrediction_cpp2`, data, X_u, priors, coords, crd_u, hyperpar, W, R)
}

#' Compute the BPS spatial prediction given a set of stacking weights
#'
#' @param data [list] two elements: first named \eqn{Y}, second named \eqn{X}
#' @param X_u [matrix] unobserved instances covariate matrix
#' @param priors [list] priors: named \eqn{\mu_b},\eqn{V_b},\eqn{a},\eqn{b}
#' @param coords [matrix] sample coordinates for X and Y
#' @param crd_u [matrix] unboserved instances coordinates
#' @param hyperpar [list] two elemets: first named \eqn{\delta}, second named \eqn{\phi}
#' @param W [matrix] set of stacking weights
#' @param R [integer] number of desired samples
#'
#' @return [list] BPS posterior predictive samples
#'
fast_BPSpred2 <- function(data, X_u, priors, coords, crd_u, hyperpar, W, R) {
    .Call(`_ASMK_fast_BPSpred2`, data, X_u, priors, coords, crd_u, hyperpar, W, R)
}

#' Compute the BPS spatial prediction given a set of stacking weights
#'
#' @param data [list] two elements: first named \eqn{Y}, second named \eqn{X}
#' @param X_u [matrix] unobserved instances covariate matrix
#' @param priors [list] priors: named \eqn{\mu_b},\eqn{V_b},\eqn{a},\eqn{b}
#' @param coords [matrix] sample coordinates for X and Y
#' @param crd_u [matrix] unboserved instances coordinates
#' @param hyperpar [list] two elemets: first named \eqn{\delta}, second named \eqn{\phi}
#' @param W [matrix] set of stacking weights
#' @param R [integer] number of desired samples
#'
#' @return [list] BPS posterior predictive samples
#'
fast_BPSpred3 <- function(data, X_u, priors, coords, crd_u, hyperpar, W, R) {
    .Call(`_ASMK_fast_BPSpred3`, data, X_u, priors, coords, crd_u, hyperpar, W, R)
}

#' Perform prediction for ASMK models - loop over prediction set
#'
#' @param data [list] two elements: first named \eqn{Y}, second named \eqn{X}
#' @param X_u [matrix] unobserved instances covariate matrix
#' @param priors [list] priors: named \eqn{\mu_b},\eqn{V_b},\eqn{a},\eqn{b}
#' @param coords [matrix] sample coordinates for X and Y
#' @param crd_u [matrix] unboserved instances coordinates
#' @param hyperpar [list] two elemets: first named \eqn{\delta}, second named \eqn{\phi}
#' @param W [matrix] set of stacking weights
#' @param R [integer] number of desired samples
#' @param J [integer] number of desired partition of prediction set
#'
#' @return [list] BPS posterior predictive samples
#'
spPredict_ASMK <- function(data, X_u, priors, coords, crd_u, hyperpar, W, R, J) {
    .Call(`_ASMK_spPredict_ASMK`, data, X_u, priors, coords, crd_u, hyperpar, W, R, J)
}

#' Perform prediction for ASMK models - loop over prediction set
#'
#' @param data [list] two elements: first named \eqn{Y}, second named \eqn{X}
#' @param X_u [matrix] unobserved instances covariate matrix
#' @param priors [list] priors: named \eqn{\mu_b},\eqn{V_b},\eqn{a},\eqn{b}
#' @param coords [matrix] sample coordinates for X and Y
#' @param crd_u [matrix] unboserved instances coordinates
#' @param hyperpar [list] two elemets: first named \eqn{\delta}, second named \eqn{\phi}
#' @param W [matrix] set of stacking weights
#' @param R [integer] number of desired samples
#' @param J [integer] number of desired partition of prediction set
#'
#' @return [list] BPS posterior predictive samples
#'
spPredict_ASMK2 <- function(data, X_u, priors, coords, crd_u, hyperpar, W, R, J) {
    .Call(`_ASMK_spPredict_ASMK2`, data, X_u, priors, coords, crd_u, hyperpar, W, R, J)
}

#' Compute the BPS posterior samples given a set of stacking weights
#'
#' @param data [list] two elements: first named \eqn{Y}, second named \eqn{X}
#' @param priors [list] priors: named \eqn{\mu_b},\eqn{V_b},\eqn{a},\eqn{b}
#' @param coords [matrix] sample coordinates for X and Y
#' @param hyperpar [list] two elemets: first named \eqn{\delta}, second named \eqn{\phi}
#' @param W [matrix] set of stacking weights
#' @param R [integer] number of desired samples
#'
#' @return [matrix] BPS posterior samples
#'
BPS_post_draws <- function(data, priors, coords, hyperpar, W, R) {
    .Call(`_ASMK_BPS_post_draws`, data, priors, coords, hyperpar, W, R)
}

#' Compute the parameters for the posteriors distribution of \eqn{\beta} and \eqn{\Sigma} (i.e. updated parameters)
#'
#' @param data [list] two elements: first named \eqn{Y}, second named \eqn{X}
#' @param priors [list] priors: named \eqn{\mu_B},\eqn{V_r},\eqn{\Psi},\eqn{\nu}
#' @param coords [matrix] sample coordinates for X and Y
#' @param hyperpar [list] two elemets: first named \eqn{\alpha}, second named \eqn{\phi}
#'
#' @return [list] posterior update parameters
#'
fit_latent_cpp <- function(data, priors, coords, hyperpar) {
    .Call(`_ASMK_fit_latent_cpp`, data, priors, coords, hyperpar)
}

#' The same fit_latent_cpp, but take as argument the distance matrix directly (does not compute it by itself from coords)
#'
#' @param data [list] two elements: first named \eqn{Y}, second named \eqn{X}
#' @param priors [list] priors: named \eqn{\mu_B},\eqn{V_r},\eqn{\Psi},\eqn{\nu}
#' @param dist [matrix] sample distance matrix
#' @param hyperpar [list] two elemets: first named \eqn{\alpha}, second named \eqn{\phi}
#'
#' @return [list] posterior update parameters
#'
fit_latent_cpp2 <- function(data, priors, dist, hyperpar) {
    .Call(`_ASMK_fit_latent_cpp2`, data, priors, dist, hyperpar)
}

#' Sample R draws from the posterior distributions
#'
#' @param poster [list] output from \code{fit_cpp} function
#' @param R [integer] number of posterior samples
#' @param par [boolean] if \code{TRUE} only \eqn{\beta} and \eqn{\sigma^2} are sampled (\eqn{\omega} is omitted)
#' @param p [integer] if \code{par = TRUE}, it specifies the column number of \eqn{X}
#'
#' @return [list] posterior samples
#'
post_draws_latent <- function(poster, R, par, p) {
    .Call(`_ASMK_post_draws_latent`, poster, R, par, p)
}

#' Compute the BPS posterior samples given a set of stacking weights
#'
#' @param data [list] two elements: first named \eqn{Y}, second named \eqn{X}
#' @param priors [list] priors: named \eqn{\mu_B},\eqn{V_r},\eqn{\Psi},\eqn{\nu}
#' @param coords [matrix] sample coordinates for X and Y
#' @param hyperpar [list] two elemets: first named \eqn{\alpha}, second named \eqn{\phi}
#' @param W [matrix] set of stacking weights
#' @param R [integer] number of desired samples
#'
#' @return [list] BPS posterior samples
#'
BPS_post_draws_latent <- function(data, priors, coords, hyperpar, W, R) {
    .Call(`_ASMK_BPS_post_draws_latent`, data, priors, coords, hyperpar, W, R)
}

#' Draw from the conditional posterior predictive for a set of unobserved covariates
#'
#' @param data [list] two elements: first named \eqn{Y}, second named \eqn{X}
#' @param X_u [matrix] unobserved instances covariate matrix
#' @param d_u [matrix] unobserved instances distance matrix
#' @param d_us [matrix] cross-distance between unobserved and observed instances matrix
#' @param hyperpar [list] two elemets: first named \eqn{\alpha}, second named \eqn{\phi}
#' @param poster [list] output from \code{fit_cpp} function
#' @param beta [matrix] posterior sample for \eqn{\beta}
#' @param sigma [matrix] posterior sample for \eqn{\Sigma}
#'
#' @return [list] posterior predictive samples
#'
r_pred_latent_cpp <- function(data, X_u, d_u, d_us, hyperpar, poster, beta, sigma) {
    .Call(`_ASMK_r_pred_latent_cpp`, data, X_u, d_u, d_us, hyperpar, poster, beta, sigma)
}

#' Evaluate the density of a set of unobserved response with respect to the conditional posterior predictive
#'
#' @param data [list] two elements: first named \eqn{Y}, second named \eqn{X}
#' @param X_u [matrix] unobserved instances covariate matrix
#' @param Y_u [matrix] unobserved instances response matrix
#' @param d_u [matrix] unobserved instances distance matrix
#' @param d_us [matrix] cross-distance between unobserved and observed instances matrix
#' @param hyperpar [list] two elemets: first named \eqn{\alpha}, second named \eqn{\phi}
#' @param poster [list] output from \code{fit_cpp} function
#' @param beta [matrix] posterior sample for \eqn{\beta}
#' @param sigma [matrix] posterior sample for \eqn{\Sigma}
#'
#' @return [double] posterior predictive density evaluation
#'
d_pred_latent_cpp <- function(data, X_u, Y_u, d_u, d_us, hyperpar, poster, beta, sigma) {
    .Call(`_ASMK_d_pred_latent_cpp`, data, X_u, Y_u, d_u, d_us, hyperpar, poster, beta, sigma)
}

#' Compute the LOOCV of the density evaluations for fixed values of the hyperparameters
#'
#' @param data [list] two elements: first named \eqn{Y}, second named \eqn{X}
#' @param priors [list] priors: named \eqn{\mu_B},\eqn{V_r},\eqn{\Psi},\eqn{\nu}
#' @param coords [matrix] sample coordinates for X and Y
#' @param hyperpar [list] two elemets: first named \eqn{\alpha}, second named \eqn{\phi}
#'
#' @return [vector] posterior predictive density evaluations
#'
dens_loocv_latent <- function(data, priors, coords, hyperpar) {
    .Call(`_ASMK_dens_loocv_latent`, data, priors, coords, hyperpar)
}

#' Compute the KCV of the density evaluations for fixed values of the hyperparameters
#'
#' @param data [list] two elements: first named \eqn{Y}, second named \eqn{X}
#' @param priors [list] priors: named \eqn{\mu_B},\eqn{V_r},\eqn{\Psi},\eqn{\nu}
#' @param coords [matrix] sample coordinates for X and Y
#' @param hyperpar [list] two elemets: first named \eqn{\alpha}, second named \eqn{\phi}
#' @param K [integer] number of folds
#'
#' @return [vector] posterior predictive density evaluations
#'
dens_kcv_latent <- function(data, priors, coords, hyperpar, K) {
    .Call(`_ASMK_dens_kcv_latent`, data, priors, coords, hyperpar, K)
}

#' Return the CV predictive density evaluations for all the model combinations
#'
#' @param data [list] two elements: first named \eqn{Y}, second named \eqn{X}
#' @param priors [list] priors: named \eqn{\mu_B},\eqn{V_r},\eqn{\Psi},\eqn{\nu}
#' @param coords [matrix] sample coordinates for X and Y
#' @param hyperpar [list] two elemets: first named \eqn{\alpha}, second named \eqn{\phi}
#' @param useKCV [boolean] if \code{TRUE} K-fold cross validation is used instead of LOOCV (no \code{default})
#' @param K [integer] number of folds
#'
#' @return [matrix] posterior predictive density evaluations (each columns represent a different model)
#'
models_dens_latent <- function(data, priors, coords, hyperpar, useKCV, K) {
    .Call(`_ASMK_models_dens_latent`, data, priors, coords, hyperpar, useKCV, K)
}

#' Compute the BPS spatial prediction given a set of stacking weights
#'
#' @param data [list] two elements: first named \eqn{Y}, second named \eqn{X}
#' @param X_u [matrix] unobserved instances covariate matrix
#' @param priors [list] priors: named \eqn{\mu_B},\eqn{V_r},\eqn{\Psi},\eqn{\nu}
#' @param coords [matrix] sample coordinates for X and Y
#' @param crd_u [matrix] unboserved instances coordinates
#' @param hyperpar [list] two elemets: first named \eqn{\alpha}, second named \eqn{\phi}
#' @param W [matrix] set of stacking weights
#' @param R [integer] number of desired samples
#'
#' @return [list] BPS posterior predictive samples
#'
BPS_latent_SpatialPrediction_cpp <- function(data, X_u, priors, coords, crd_u, hyperpar, W, R) {
    .Call(`_ASMK_BPS_latent_SpatialPrediction_cpp`, data, X_u, priors, coords, crd_u, hyperpar, W, R)
}

